- can't use:
  - Commands.cpp -- require alias, cvar + command buffer support
  - FileSystem... -- unfinished

---------- console cmdline / command system -----------
- Cmd_ForwardToServer(): rename to CL_UnhandledCommand(), set as callback when initializing command system; should be implemented
  as callback in CCommandBuffer (name?) class
- CCmdLineEditor -> GConCmdLine
  properties:
    - editLine[]
    - history[]
    - cursorPos (for visualization)
    - RegisterCompletion - for automated completion
    - KeyEvent - edit line, browse history, call completion
    ? command system
    ? execution buffer (can add strings, exec files)
! when implement new command completion system, can change public cmdAlias_t,cmdFunc_t declarations -> private for "cmd.cpp";
  public "cvar_vars", "cmdAlias", "cmdFuncs" -> static
- dedicated server, GConCmdLine:
  - convert VK_KEY -> K_KEY and pass to GConCmdLine
  - use cursorPos for cursor visualization

-------------- WinMain() -------------------
- WinMain():
  appInit() -- pass NULL (==outputDevice) for GUI and OutputDeviceWin32Console for dedicated (cvar "dedicated" unknown here ?)
- CL_Init: set (add) OutputDeviceConsole
  ? func SetOutputDevice() - can add output devices
- appPrintf() etc:
  - should be able to use few output devices
  - ability to hook output (for rcon etc)

--------------- Output ---------------------
- COutputDevice:
   - bool useColors -- when "false" - UncolString before output (e.g. for file logging)
   - appPrintf, appWPrintf, appDPrintf -> called via GLog etc.
     Implement wrappers (appPrintf()==GLog->Printf() etc) in separate cpp file (CoreWrapper.cpp or CoreGlobal.cpp ...)
   - wrapper should allow placing few COutputDevice's; they should be called in LIFO order, and function should be able
     to prevent sending text to remainder of loggers (completely catch output)
- CErrorHandler:
   - bool isDropError -- when Com_DropError; no such error in Core, so can place DropError() function in Engine; this func
     will set "GDropError=true", and call appError(msg)
     (?) may implement as:
         a) "bool Engine::GDropError" - separate var, and GErr.Reset() will not reset this var (but, really, Reset() should
            be called mostly after DropError() !) -- will reset this var manually
         b) make derived "class GEngineErrorHandler <- GErrorHandler" with "virtual Reset()" and "bool dropError"; this will
            require to set GErr with appInit()
     (-) can remove func appNonFatalError() from Core, and, may be, rename appFatalError() to appError(), because no other
         errors in Core
     (!) isDropError == !fatalError; fatalError=true (now) called from Win32ExceptHandler() only, so, when not used WIN32_SEH,
         any GFP will raise error without fatalError==true, and app will not crash -- incorrect!

------------------- GUI --------------------
- make K_CONSOLE, K_MENU, K_CANCEL -- as aliases or vars, do not use '`' or K_ESCAPE
- class CScreenObject {
	Draw()
	bool HandleEvent() == Key_Event()
	bool Close() -- on K_CLOSE etc
	Tick() == current Run()
  }
  - use for Menu, Console, Game (3D with world), Cinematic, Chat, HUD, LoadingSplash, DownloadingInfo
    - SCR_StopCinematic(): remove from keys.cpp and cl_input.cpp -> move to CCinematic::HandleEvent()
? screenshot: may perform detection of correct place to perform from client (not inside renderer):
  - require backend to not cache drawings and immediately perform drawing of 3D and 2D objects:
    - 3D - exec frontend, sort surfaces and draw
    - 2D - sorting will affect draw order and create incorrect scene, so - can exec immediately too
    * NOTE: command buffer was taken from Q3 engine ...
- currently, all screen objects depends on client or client_static structures - try to cut necessary fields
  to separate structure
  - time parameters: cls.realtime, cls.frametime
  - GUI state: cls.key_dest, cls.loading, cl.cinematicActive, cls.download

------------------- Misc -------------------
- math:
  - WorldToModelCoord() etc.: make CWorldObject class with position+axis props + conversion funcs
- network:
  - make channel_t (different name ??) as class, TcpChannel+LoopbackChannel as childs
  ? channel_t -> CNetStream
- file system:
  - CFile (opened file object) - add "bool errorOnEof" - DropError() (FatalError?) when trying to read beyond EOF
  - stream helpers: ReadInt(), ReadFloat(), ReadByte(), ReadShort() -- with BIG_ENDIAN support (for Float/Int/Short)
  ? stream helpers: ReadInts(), ReadFloats() ... -- read array of data, with BIG_ENDIAN support

------------ New renderer system -----------
- make build target: "static build with single GL renderer" (to feel free for renderer API modification)
- change GetRefAPI() -> something another (different method of renderer creation; can change backend only)
- separate renderer (math only) and backend (OpenGL); call hierarchy: mainEngine->renderer->backend->gl
- backend should provide "caps" field:
  - rect textures (GL_NV_texture_rectangle: clamp, no mipmap)
  - rect textures 2 (GL_ARB_texture_non_power_of_two: full-feautered textures)
  - compressed textures (for disabling by menu)
  - fast blend (for soft renderer: can draw console etc with opaque rects)
  - fast culling (for soft: when "false" will try to cull everything before sending to backend)
  - some lighting info (software, hardware with/without cubemaps etc)
- images.cpp -> renderer (not backend)
- (abstract) class CImage, wisible from GUI/client - implementation in renderer, some service funcs
  (uploading, retreiving from screen, rendering to texture) - in backend
? vid_restart: restart backend ? (renderer restarting - unneded ??); rename cmd ?
? share model/map loading with cmodel (separate into own library, used by server/client/renderer)
- CImage->CShader (CMaterial?); CImage->CGlImage; CMaterial->CGlMaterial
- sky drawing: AddSkySurface() - during frontend pass (if r_fastSky==0); backend will only draw sky grid;
  this will eliminate sky surfaces from sorted surfaces array
- 2D-drawing (non-world, i.e. GUI/HUD): don't need to buffer everything, can draw immediately; buffer only
  3D world surfaces for later sorting and drawing in preferred order (sort by light/model/model-bone/shader/BSP-order ...);
  3D drawing: after RenderScene() call, will perform frontend -> buffer -> sorted buffer -> backend; not needed
  backend command list ?
  ! check speed changing after removing backend cmd buffer
- client rendering:
  - screen manager - top level, draw GUI and HUD; can draw 3D in GUI/HUD
  - primary world 3D scene manager - entities, sprites/fx, dlights ...; will call renderer->DrawScene()
- NullBackend (builtin?) - empty functions; may be useful for on-fly switching to dedicated server and to back GUI
