! rename "gl_local.h" to something another (and change "#ifndef __GL_LOCAL_...")
- SHADER_WALL -> SHADER_WORLD (depthwrite, depthtest) or add SHADER_HUD (no write/test)
- add SHADER_SPRITE: alpha/alphatest, depth-write/test, sort=5, rgb/alpha-gen=vertex
? don't need shader->sortParam other than sky/opaque/seethrough (may be, +coronas +hud)
! implement hWnd caching (move CreateWindow()/DeleteWindow() from ref to main, create wnd on startup and delete on exit or
  when renderer does not require it; this will (I hope) prevent app from loosing focus while vid_restart etc.)

?? add mean filter for DrawFPS() (ignore dropped frames and long (with FS access) frames)
! do not render while window is minimized (less CPU usage)
- r_nocull works only with frustum culling (extend cvar or add another ...)
!! vertex arrays are not 16-byte aligned (see gl.log)

- shaders:
  ? make shader_t.name dynamic allocated (~ basenamed_t)
  ? sky shader: specify color for "gl_fastSky"
  ? field: size of shader (for reusing it from deleted shader (temp shaders)) (Is "delete/reuse shader" needed ??)
? "gl_fastSky 2" - use "*sky" shader; add color to "*sky" shader (color-filled skies)
? gl_maxVerts cvar [1..2048] -- used by RB_CheckOverflow()
! correct lightscaling (max_scale = 255/max(r,g,b)) for overbright
? gl_lastValidRenderer (reset all config params ("reset gl_*" ??) if changed; example of value -- "Riva TNT2/SSE")
! overbright of DYNAMIC lightmaps (NORMAL modulated in image.c::Upload()) and model skins

--------- Mandatory ------------
VISIBLE:
- dlights
- models (entities)
  - md2
    - "outline" effect (quad damage etc.)
    - flashing fx (sometimes rgbGen entity, or 2 shaders: with/without flashing ?)
    - lefthand (weapon model)
    - dynamic lighting (RecursiveLightPoint)
- screen blending (underwater etc.)
- shadows
INVISIBLE:
- multitexturing (with lightmap lightscale when have multitex. and no env_combine)
! freeing of old images (and "bool temp" or "int usage" flag)
FOR GAME:
- r_lightlevel (really, needs another way to provide lighting info for game ...)
DEBUG:
- r_fullbright, gl_lightmap
- gl_stings (gfxinfo)

--------- Improvements -----------

? rail fx (change)
- optimize sky box drawing:
  - make more than 6 rects (6 * skyTessSize^2)
  - perform fast surface tessalation (need only verts.xyz)
  - can tesselate SOME surface as axis-aligned rects (find surf planar mins/maxs)
  - find fast cases, when surface placed only on one plane (can use surface normal to determine IMPOSSIBLE planes)
- gl_showbboxes, gl_singleShader, gl_showtris -> cheat
- vertex lighting:
  - surface simplification + subdivision (!) for complex lightmaps (non-gradient color change) - as option
    (lighting = "lightmap", "vertex", "hq vertex")
- gl_logFile:
  ? remove "GL_" and "gl" prefixes (looks like OpenGL spec)
  ? add error checking after commands (qgl.in: ERROR)
  ?? add profiling (qgl.in: PROFILE)
? make area_t, cluster_t, area.clusterList, cluster.leafList (faster MarkLeafs()/LightPoint())
- gl_overbright:
  - 0-none (force off), 1-"1bit" (force on), 2-"auto" (ON when (vertexLight || multitext. && !env_combine) && fullscreen (??))
  - remove gl_overbrightBits
  - menu selectable
- gl_model:
  - add surfaceFast_t (for use with FastIterator())
- dynamic lightmaps:
  1) upload all at once (??)
  2) make multi-pass shaders (no uploads, RGBGEN_LIGHTSTYLE)
     - lightstyle value is 0..2 (up to double brightness)
     - maps with slow dynamic lightmaps: market, alley1 (look outside world), rc4 (at start point)
? make skins for models with 1 frame to be sh.fast==true (and implement it in AGP memory);
  Problem: how to apply lighting? (and: skins may be dynamically changed from "fast" to "slow")
- triangle models: build lods
? profile uploading (r_speeds, gl_finish 2)
? "screenshort levelshot" -> "levelshot"
? "gl_alphaLightmap" (arc, def: "1") -- can disable lighting of alpha/warp surfaces; add option to menu
  (easy implement, but naming problems ...)
- water lightmaps:
  ? try to GENERATE vertex light for water/windows ??
- improve SURF_ALPHA quality on near distances (determine const for checking this requirement?):
  - scale (enlarge) texture with keeping alpha = 0 or 255
  ? make 2 copies of image (when necessary): with and without alpha-channel (have some KP maps with same texture used
    as window and as wall) -- IMAGE_ALPHA flag (use different resampling techniques)

---------------------------
- inlineModels: RF_TRANSLUCENT/RF2_ALPHA: qglColor4f (1,1,1,0.25)/qglColor4f(1,1,1,1) + blend + no lightmap
  (require entstring preprocessing?)
? what to do with "intens" param in GLimp_SetGamma() ? remove ??
