#!/usr/bin/perl -w

#------------------------------------------------------------------------------
#	Defines
#------------------------------------------------------------------------------

if (1) {
	#...... work .......
	$infile = "ref.in";
	$outhdr = "../ref_decl.h";
	$outcode = "../ref_impl.h";
	$outdef = "../ref_defs.h";
} else {
	#...... test .......
	$infile = "ref.in.test";
	$outhdr = "decl.h";
	$outcode = "impl.h";
	$outdef = "defs.h";
}

$strucname = "ri";
$typename = "refImport_t";


#------------------------------------------------------------------------------
#	Functions
#------------------------------------------------------------------------------


sub getline {
	while ($line = <IN>)
	{
		# remove CR/LF
		$line =~ s/\r//;
		$line =~ s/\n//;
		# remove comments
		$line =~ s/\s*\/\/.*//;
		# ignore empty lines
		next if $line eq "";
		return 1;
	}
	return 0;
}


#------------------------------------------------------------------------------
#	Parsing input file
#------------------------------------------------------------------------------


sub EmitStruc {
	my $str = $args;
	# remove default arguments from structure declaration
	$str =~ s/\s*=\s*\w+\s*//g;
	printf (HDR "\t%s\t(*_%s) (%s);\n", $type, $func, $str);
}

sub EmitDefine1 {
	@args = split (',', $args);
	if ($args[$#args] =~ /\.\.\./) {
		# vararg function
		printf (DEFS "#define %s\t$strucname._%s\n", $func, $func);
	} else {
		# regular function, may be overloaded - so make inline code
		print DEFS "inline $type $func ($args)\n{\n\t";
		print DEFS "return " if $type ne "void";
		print DEFS "$strucname._$func (";
		# args
		my $i = 0;
		for $arg (@args) {
			my (undef, $param, undef) = $arg =~ / \s* (\S+ .* [\*\s]) (\w+) (\[.*\])? /x;
			if (defined($param)) {
				print (DEFS ", ") if $i > 0;
				print (DEFS $param);
			}
			$i++;
		}
		# finish
		print (DEFS ");\n}\n");
	}
}

sub EmitDecl {
	printf (DEFS "%s\t%s (%s);\n", $type, $func, $args);
}

sub EmitImpl {
	print (CODE ",") if $num > 0;
	printf (CODE "\n\t%s", $func);
}

sub EmitHdrPrep {
	printf (HDR "%s\n", $line);
}

sub EmitDefsPrep {
	printf (DEFS "%s\n", $line);
}

sub EmitCodePrep {
	printf (CODE "\n%s\n", $line);
}

# Usage: Parse (<per-header func>)
sub Parse {
	my $sub;
	my ($subBegin, $subPreproc) = @_;

	open (IN, $infile) || die "Input file ", $infile, " not found";
	$num = 0;
	while (getline())
	{
		if ($line =~ /\# .+/x) {
			&$subPreproc () if defined $subPreproc;
		} else {
			($type, $func, $args) = $line =~ /^ \s* (\S+ [^(]* [\*\s]) (\w+) \s* \( (.*) \) \s* ; $/x;
			($type) = $type =~ /\s*(\S.*\S)\s*/;	# truncate leading and trailing spaces

			&$subBegin () if defined $subBegin;
			$num++;
		}
	}
	close (IN);
}


#------------------------------------------------------------------------------
#	Main program
#------------------------------------------------------------------------------

# open files
open (HDR, ">$outhdr") || die "Cannot create file ", $outhdr;
print (HDR "// Autogenerated file: do not modify\n\n");
open (CODE, ">$outcode") || die "Cannot create file ", $outcode;
print (CODE "// Autogenerated file: do not modify\n\n");
open (DEFS, ">$outdef") || die "Cannot create file ", $outdef;
print (DEFS "// Autogenerated file: do not modify\n\n");

Parse ();
$numFuncs = $num;
printf ("Found %d functions ...\n", $numFuncs);


#------------------------------------------------------------------------------
#	Creating header part
#------------------------------------------------------------------------------

print HDR <<EOF
typedef struct {
	int		struc_size;
EOF
;
Parse ("EmitStruc", "EmitHdrPrep");

print HDR <<EOF
} $typename;

extern $typename $strucname;

EOF
;
#------------------------------------------------------------------------------
#	Creating defines
#------------------------------------------------------------------------------

print (DEFS "#ifdef DYNAMIC_REF\n\n");
Parse ("EmitDefine1", "EmitDefsPrep");
print (DEFS "\n#else\n\n");
Parse ("EmitDecl", "EmitDefsPrep");
print (DEFS "\n#endif\n\n");


#------------------------------------------------------------------------------
#	Creating code part
#------------------------------------------------------------------------------

print CODE <<EOF
static $typename $strucname = {
	sizeof($typename),
#ifndef DEDICATED_ONLY
EOF
;
Parse ("EmitImpl", "EmitCodePrep");

print CODE <<EOF

#endif // DEDICATED_ONLY
};

EOF
;
# close files
close (HDR);
close (CODE);
close (DEFS);
