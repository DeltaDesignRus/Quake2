#!/usr/bin/perl -w

#------------------------------------------------------------------------------
#	Defines
#------------------------------------------------------------------------------

if (1) {
	#...... work .......
	$infile1  = "../engine.h";
	$outcode1 = "../engine_exp.h";
	$outdef1  = "../engine_intf.h";
	$infile2  = "../renderer.h";
	$outcode2 = "../rexp_exp.h";
	$outdef2  = "../rexp_intf.h";
} else {
	#...... test .......
	print "*** TEST RUN ***\n";
	$infile1  = "engine.test.h";
	$outcode1 = "engine_exp.h";
	$outdef1  = "engine_intf.h";
	$infile2  = "renderer.test.h";
	$outcode2 = "rexp_exp.h";
	$outdef2  = "rexp_intf.h";
}

$strucname1 = "ri";
$typename1  = "refImport_t";
$strucname2 = "re";
$typename2  = "refExport_t";


#------------------------------------------------------------------------------
#	Functions
#------------------------------------------------------------------------------


sub getline {
	while ($line = <IN>)
	{
		# remove CR/LF
		$line =~ s/\r//;
		$line =~ s/\n//;
		# remove comments
		$line =~ s/\s*\/\/.*//;
		# ignore empty lines
		next if $line eq "";
		return 1;
	}
	return 0;
}


#------------------------------------------------------------------------------
#	Parsing input file
#------------------------------------------------------------------------------


sub EmitStruc {
	my $str = $args;
	# remove default arguments from structure declaration
	$str =~ s/\s*=\s*\w+\s*//g;
	print (DEFS "\t$type\t(*${spref}$sname) ($str);\n");
}

sub EmitDefine {
	@args = split (',', $args);
	#!! when parsing args == "()" instead of "(void)" -> perl will produce warning "use of uninit value"
	if ($#args > 0 && $args[$#args] =~ /\.\.\./) {
		# vararg function
		die "Cannot parse overloaded vararg function \"$func\"\n" if $func ne $sname;	# cannot #define overloaded function
		print (DEFS "#define ${npref}$func\t$strucname.${spref}$sname\n");
	} else {
		# regular function, may be overloaded - so make inline code
		print DEFS "inline $type ${npref}$func ($args)\n{\n\t";
		print DEFS "return " if $type ne "void";
		print DEFS "$strucname.${spref}$sname (";
		# args
		my $i = 0;
		for $arg (@args) {
			my ($param) = $arg =~ / \s* [^=]+ [\*\&\s] (\w+) (\[.*\])? (\s*= .*)? $/x;
			if (defined($param)) {
				print (DEFS ", ") if $i > 0;
				print (DEFS $param);
			}
			$i++;
		}
		# finish
		print (DEFS ");\n}\n");
	}
}

sub EmitDefine2 {
	print (DEFS "#define ${npref}$func\t${rend}::${spref}$func\n");
}

sub EmitDecl {
	print (DEFS "$type\t$func ($args);\n");		#?? unused
}

sub EmitImpl {
	print (CODE ",") if $num > 0;
	print (CODE "\n\t$func");
}

sub EmitDefsPrep {
	print (DEFS "$line\n");
}

sub EmitCodePrep {
	print (CODE "\n$line\n");
}

# Usage: Parse (<per-header func>)
sub Parse {
	my $sub;
	my ($subBegin, $subPreproc) = @_;
	my %names = ();

	open (IN, $infile) || die "Input file ", $infile, " not found";
	$num = 0;
	while (getline())
	{
		if ($line =~ /\# .+/x) {
			&$subPreproc () if defined $subPreproc;
		} else {
			($type, $func, $args) = $line =~ /^ \s* (\S+ [^(]* [\*\&\s]) (\w+) \s* \( (.*) \) \s* ; $/x;
			($type) = $type =~ /\s*(\S.*\S)\s*/;	# truncate leading and trailing spaces

			my $n = 0;
			$sname = $func;
			while (1) {
				last if !exists $names{$sname};
				$n++;
				$sname = "$func$n";
			}
			$names{$sname} = 1;		# mark as defined

			&$subBegin () if defined $subBegin;
			$num++;
		}
	}
	close (IN);
	return $num;
}


#==============================================================================
#	PARSING ENGINE DEFINES
#==============================================================================

# open files
open (CODE, ">$outcode1") || die "Cannot create file $outcode1";
print (CODE "// Autogenerated file: do not modify\n\n");
open (DEFS, ">$outdef1") || die "Cannot create file $outdef1";
print (DEFS "// Autogenerated file: do not modify\n\n");
$infile    = $infile1;
$strucname = $strucname1;
$npref     = "";		# name prefix
$spref     = "_";		# stricture prefix

printf ("Found %d engine functions ...\n", Parse ());


#------------------------------------------------------------------------------
#	Creating structure part
#------------------------------------------------------------------------------

print DEFS <<EOF
struct $typename1
{
	int		struc_size;
EOF
;
Parse ("EmitStruc", "EmitDefsPrep");

print DEFS <<EOF
};

EOF
;
#------------------------------------------------------------------------------
#	Creating defines
#------------------------------------------------------------------------------

print DEFS <<EOF
#if STATIC_BUILD || !IS_RENDERER
// engine itself or statically linked renderer
#include "engine.h"
#else // dynamic renderer -> engine interface

extern $typename1 $strucname;

EOF
;
Parse ("EmitDefine", "EmitDefsPrep");
print DEFS <<EOF

#endif // renderer -> engine interface

EOF
;


#------------------------------------------------------------------------------
#	Creating code part
#------------------------------------------------------------------------------

print CODE <<EOF
static const $typename1 $strucname = {
	sizeof($typename1),
EOF
;
Parse ("EmitImpl", "EmitCodePrep");

print (CODE "\n};\n\n");


# close files
close (CODE);
close (DEFS);


#==============================================================================
#	PARSING RENDERER DEFINES
#==============================================================================

# open files
open (CODE, ">$outcode2") || die "Cannot create file $outcode2";
print (CODE "// Autogenerated file: do not modify\n\n");
open (DEFS, ">$outdef2") || die "Cannot create file $outdef2";
print (DEFS "// Autogenerated file: do not modify\n\n");
$infile    = $infile2;
$strucname = $strucname2;
$npref     = "RE_";
$spref     = "";

$rend      = "OpenGLDrv";

printf ("Found %d renderer functions ...\n", Parse ());


#------------------------------------------------------------------------------
#	Creating structure part
#------------------------------------------------------------------------------

print DEFS <<EOF
struct $typename2
{
	int		struc_size;
EOF
;
Parse ("EmitStruc", "EmitDefsPrep");

print (DEFS "};\n\n");


#------------------------------------------------------------------------------
#	Creating defines
#------------------------------------------------------------------------------

print DEFS <<EOF
#if !IS_RENDERER
#	if !SINGLE_RENDERER

extern $typename2 $strucname;

EOF
;
Parse ("EmitDefine", "EmitDefsPrep");
print DEFS <<EOF

#	else // SINGLE_RENDERER

namespace $rend
{
#include "renderer.h"
};

EOF
;
Parse ("EmitDefine2", "EmitDefsPrep");

print DEFS <<EOF

#	endif // SINGLE_RENDERER
#endif // IS_RENDERER

EOF
;

#------------------------------------------------------------------------------
#	Creating code part
#------------------------------------------------------------------------------

print CODE <<EOF
// don't know why, but VC6 (VC7/GCC-untested) will drop var without following line:
extern const $typename2 $strucname;

const $typename2 $strucname = {
	sizeof($typename2),
EOF
;
Parse ("EmitImpl", "EmitCodePrep");

print (CODE "\n};\n\n");


# close files
close (CODE);
close (DEFS);
