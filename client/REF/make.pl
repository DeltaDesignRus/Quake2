#!/usr/bin/perl -w

#------------------------------------------------------------------------------
#	Defines
#------------------------------------------------------------------------------

if (1) {
	#...... work .......
	$infile1  = "engine.in";
	$outhdr1  = "../ref_decl.h";
	$outcode1 = "../ref_impl.h";
	$outdef1  = "../ref_defs.h";
	$infile2  = "renderer.in";
	$outhdr2  = "../rexp_decl.h";
	$outdef2  = "../rexp_defs.h";
} else {
	#...... test .......
	$infile1  = "engine.in.test";
	$outhdr1  = "ref_decl.h";
	$outcode1 = "ref_impl.h";
	$outdef1  = "ref_defs.h";
	$infile2  = "renderer.in.test";
	$outhdr2  = "rexp_decl.h";
	$outdef2  = "rexp_defs.h";
}

$strucname1 = "ri";
$typename1  = "refImport_t";
$strucname2 = "re";
$typename2  = "refExport_t";


#------------------------------------------------------------------------------
#	Functions
#------------------------------------------------------------------------------


sub getline {
	while ($line = <IN>)
	{
		# remove CR/LF
		$line =~ s/\r//;
		$line =~ s/\n//;
		# remove comments
		$line =~ s/\s*\/\/.*//;
		# ignore empty lines
		next if $line eq "";
		return 1;
	}
	return 0;
}


#------------------------------------------------------------------------------
#	Parsing input file
#------------------------------------------------------------------------------


sub EmitStruc {
	my $str = $args;
	# remove default arguments from structure declaration
	$str =~ s/\s*=\s*\w+\s*//g;
	print (HDR "\t$type\t(*${spref}$func) ($str);\n");
}

sub EmitDefine {
	@args = split (',', $args);
	#!! when parsing args == "()" instead of "(void)" -> perl will produce warning "use of uninit value"
	if ($args[$#args] =~ /\.\.\./) {
		# vararg function
		print (DEFS "#define ${npref}$func\t$strucname.${spref}$func\n");
	} else {
		# regular function, may be overloaded - so make inline code
		print DEFS "inline $type ${npref}$func ($args)\n{\n\t";
		print DEFS "return " if $type ne "void";
		print DEFS "$strucname.${spref}$func (";
		# args
		my $i = 0;
		for $arg (@args) {
			my ($param) = $arg =~ / \s* [^=]+ [\*\s] (\w+) (\[.*\])? (\s*= .*)? $/x;
			if (defined($param)) {
				print (DEFS ", ") if $i > 0;
				print (DEFS $param);
			}
			$i++;
		}
		# finish
		print (DEFS ");\n}\n");
	}
}

sub EmitDecl {
	print (DEFS "$type\t$func ($args);\n");
}

sub EmitImpl {
	print (CODE ",") if $num > 0;
	print (CODE "\n\t$func");
}

sub EmitHdrPrep {
	print (HDR "$line\n");
}

sub EmitDefsPrep {
	print (DEFS "$line\n");
}

sub EmitCodePrep {
	print (CODE "\n$line\n");
}

# Usage: Parse (<per-header func>)
sub Parse {
	my $sub;
	my ($subBegin, $subPreproc) = @_;

	open (IN, $infile) || die "Input file ", $infile, " not found";
	$num = 0;
	while (getline())
	{
		if ($line =~ /\# .+/x) {
			&$subPreproc () if defined $subPreproc;
		} else {
			($type, $func, $args) = $line =~ /^ \s* (\S+ [^(]* [\*\s]) (\w+) \s* \( (.*) \) \s* ; $/x;
			($type) = $type =~ /\s*(\S.*\S)\s*/;	# truncate leading and trailing spaces

			&$subBegin () if defined $subBegin;
			$num++;
		}
	}
	close (IN);
}


#==============================================================================
#	PARSING ENGINE DEFINES
#==============================================================================

# open files
open (HDR, ">$outhdr1") || die "Cannot create file $outhdr1";
print (HDR "// Autogenerated file: do not modify\n\n");
open (CODE, ">$outcode1") || die "Cannot create file $outcode1";
print (CODE "// Autogenerated file: do not modify\n\n");
open (DEFS, ">$outdef1") || die "Cannot create file $outdef1";
print (DEFS "// Autogenerated file: do not modify\n\n");
$infile    = $infile1;
$strucname = $strucname1;
$npref     = "";		# name prefix
$spref     = "_";		# stricture prefix

Parse ();
$numFuncs = $num;
printf ("Found %d engine functions ...\n", $numFuncs);


#------------------------------------------------------------------------------
#	Creating header part
#------------------------------------------------------------------------------

print HDR <<EOF
typedef struct {
	int		struc_size;
EOF
;
Parse ("EmitStruc", "EmitHdrPrep");

print HDR <<EOF
} $typename1;

extern $typename1 $strucname;

EOF
;
#------------------------------------------------------------------------------
#	Creating defines
#------------------------------------------------------------------------------

print (DEFS "#ifdef DYNAMIC_REF\n\n");
Parse ("EmitDefine", "EmitDefsPrep");
print (DEFS "\n#else\n\n");
Parse ("EmitDecl", "EmitDefsPrep");
print (DEFS "\n#endif\n\n");


#------------------------------------------------------------------------------
#	Creating code part
#------------------------------------------------------------------------------

print CODE <<EOF
static $typename1 $strucname = {
	sizeof($typename1),
#ifndef DEDICATED_ONLY
EOF
;
Parse ("EmitImpl", "EmitCodePrep");

print CODE <<EOF

#endif // DEDICATED_ONLY
};

EOF
;
# close files
close (HDR);
close (CODE);
close (DEFS);


#==============================================================================
#	PARSING RENDERER DEFINES
#==============================================================================

# open files
open (HDR, ">$outhdr2") || die "Cannot create file $outhdr2";
print (HDR "// Autogenerated file: do not modify\n\n");
#??open (CODE, ">$outcode2") || die "Cannot create file $outcode2";
#??print (CODE "// Autogenerated file: do not modify\n\n");
open (DEFS, ">$outdef2") || die "Cannot create file $outdef2";
print (DEFS "// Autogenerated file: do not modify\n\n");
$infile    = $infile2;
$strucname = $strucname2;
$npref     = "RE_";
$spref     = "";

Parse ();
$numFuncs = $num;
printf ("Found %d renderer functions ...\n", $numFuncs);

#------------------------------------------------------------------------------
#	Creating header part
#------------------------------------------------------------------------------

print HDR <<EOF
typedef struct {
	int		struc_size;
	unsigned *flags;
EOF
;
Parse ("EmitStruc", "EmitHdrPrep");

print HDR <<EOF
} $typename2;

EOF
;
#------------------------------------------------------------------------------
#	Creating defines
#------------------------------------------------------------------------------

Parse ("EmitDefine", "EmitDefsPrep");


# close files
close (HDR);
#??close (CODE);
close (DEFS);
