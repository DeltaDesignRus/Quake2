#include "gl_local.h"
#include "gl_sky.h"

static float skyMins[2][6], skyMaxs[2][6];


#define	ON_EPSILON		0.1f			// point on plane side epsilon
#define	MAX_CLIP_VERTS	64

typedef enum {SIDE_FRONT, SIDE_BACK, SIDE_ON};

static void ClipSkyPolygon (int numVerts, vec3_t verts, int stage)
{
	float	*norm;
	float	*vec;
	qboolean	front, back;
	float	dists[MAX_CLIP_VERTS];
	int		sides[MAX_CLIP_VERTS];
	vec3_t	newv[2][MAX_CLIP_VERTS];	// new polys
	int		newc[2];					// number of verts in new polys
	int		i;

	static vec3_t skyClip[6] = {
		{ 1, 1, 0},
		{ 1,-1, 0},
		{ 0,-1, 1},
		{ 0, 1, 1},
		{ 1, 0, 1},
		{-1, 0, 1}
	};

	static int vecToSt[6][3] = {	// s = [0]/[2], t = [1]/[2]
		{-2, 3, 1},
		{ 2, 3,-1},
		{ 1, 3, 2},
		{-1, 3,-2},
		{-2,-1, 3},
		{-2, 1,-3}
	};


	if (!numVerts) return;			// empty polygon

	if (numVerts > MAX_CLIP_VERTS - 2)
		Com_Error (ERR_DROP, "ClipSkyPolygon: MAX_CLIP_VERTS hit");

	if (stage == 6)
	{	// fully clipped -- update skymins/skymaxs
		int		axis;
		vec3_t	av, v;
		float	*vp;

		// decide which face it maps to
		VectorClear (v);
		for (i = 0, vp = verts; i < numVerts; i++, vp += 3)
			VectorAdd (vp, v, v);
		av[0] = fabs(v[0]);
		av[1] = fabs(v[1]);
		av[2] = fabs(v[2]);
		// Here: v = sum vector, av = abs(v)
		if (av[0] > av[1] && av[0] > av[2])
			axis = (v[0] < 0) ? 1 : 0;
		else if (av[1] > av[2] && av[1] > av[0])
			axis = (v[1] < 0) ? 3 : 2;
		else
			axis = (v[2] < 0) ? 5 : 4;

		// project new texture coords
		for (i = 0; i < numVerts; i++, verts += 3)
		{
			int		j;
			float	s, t, dv;

			j = vecToSt[axis][2];
			if (j < 0)	dv = -verts[-j - 1];
			else		dv = verts[j - 1];

			if (dv < 0.001f) continue;	// don't divide by zero

			j = vecToSt[axis][0];
			if (j < 0)	s = -verts[-j - 1] / dv;
			else		s = verts[j - 1] / dv;

			j = vecToSt[axis][1];
			if (j < 0)	t = -verts[-j - 1] / dv;
			else		t = verts[j - 1] / dv;

			if (s < skyMins[0][axis]) skyMins[0][axis] = s;
			if (s > skyMaxs[0][axis]) skyMaxs[0][axis] = s;
			if (t < skyMins[1][axis]) skyMins[1][axis] = t;
			if (t > skyMaxs[1][axis]) skyMaxs[1][axis] = t;
		}
		return;
	}

	front = back = false;
	norm = skyClip[stage];
	for (i = 0, vec = verts; i < numVerts; i++, vec += 3)
	{
		float	d;

		d = DotProduct (vec, norm);
		if (d > ON_EPSILON)
		{
			front = true;
			sides[i] = SIDE_FRONT;
		}
		else if (d < -ON_EPSILON)
		{
			back = true;
			sides[i] = SIDE_BACK;
		}
		else
			sides[i] = SIDE_ON;
		dists[i] = d;
	}

	if (!front || !back)
	{	// not clipped
		ClipSkyPolygon (numVerts, verts, stage + 1);
		return;
	}

	// clip it
	sides[i] = sides[0];
	dists[i] = dists[0];
	VectorCopy (verts, (verts + (i * 3)));
	newc[0] = newc[1] = 0;

	for (i = 0, vec = verts; i < numVerts; i++, vec += 3)
	{
		int		j;
		float	d;

		switch (sides[i])
		{
		case SIDE_FRONT:
			VectorCopy (vec, newv[0][newc[0]]);
			newc[0]++;	// cannot insert this command to VectorCopy(), because it is a macro ...
			break;
		case SIDE_BACK:
			VectorCopy (vec, newv[1][newc[1]]);
			newc[1]++;
			break;
		case SIDE_ON:
			VectorCopy (vec, newv[0][newc[0]]);
			newc[0]++;
			VectorCopy (vec, newv[1][newc[1]]);
			newc[1]++;
			break;
		}

		if (sides[i] == SIDE_ON || sides[i+1] == SIDE_ON || sides[i+1] == sides[i])
			continue;		// line placed on one side of clip plane

		// line intersects clip plane: split line to 2 parts by adding new point
		d = dists[i] / (dists[i] - dists[i+1]);
		for (j = 0; j < 3; j++)
		{
			float	e;

			e = vec[j] + d * (vec[j + 3] - vec[j]);
			newv[0][newc[0]][j] = e;
			newv[1][newc[1]][j] = e;
		}
		newc[0]++;
		newc[1]++;
	}

	// process new polys
	if (newc[0]) ClipSkyPolygon (newc[0], newv[0][0], stage + 1);
	if (newc[1]) ClipSkyPolygon (newc[1], newv[1][0], stage + 1);
}


// In: s, t in range [-1..1]; out: tex = {s,t}, vec
static void MakeSkyVec (float s, float t, int axis, float scale, float *tex, vec3_t vec)
{
	vec3_t		b;
	int			i;

	static int stToVec[6][3] = {	// 1 = s, 2 = t, 3 = zFar
		{ 3,-1, 2},
		{-3, 1, 2},
		{ 1, 3, 2},
		{-1,-3, 2},
		{-2,-1, 3},		// 0 degrees yaw, look straight up
		{ 2,-1,-3}		// look straight down
	};

	b[0] = s * scale;
	b[1] = t * scale;
	b[2] = scale;

	for (i = 0; i < 3; i++)
	{
		int		tmp;

		tmp = stToVec[axis][i];
		vec[i] = tmp < 0 ? -b[-tmp - 1] : b[tmp - 1];
	}

	if (tex)
	{
		// convert range [-1, 1] to [0, 1]
		s = (s + 1) / 2;
		s = bound(s, 0, 1);
		t = (t + 1) / 2;
		t = bound(t, 0, 1);
#if 0
		if (!currentShader->bad && Cvar_VariableInt("skyfix"))
		{
			float	fix, fix2;

			fix = 0.5f / currentShader->width * Cvar_VariableInt("skyfix");
			fix2 = 1 - 2 * fix;
			s = fix + fix2 * s;
			t = fix + fix2 * t;
		}
#endif
		tex[0] = s;
		tex[1] = 1.0 - t;
	}
}


#define SKY_TESS_SIZE	4

#if (SKY_TESS_SIZE*2+1) * (SKY_TESS_SIZE*2+1) > MAX_VERTEXES
#  error Not enough vertex buffer size: cannot tesselate sky surface
#endif

void GL_ClearSkyBox (void)
{
	int		i;

	//!! WRONG !!
	// clear bounds for all sky box planes
	for (i = 0; i < 6; i++)
	{
		skyMins[0][i] = skyMins[1][i] = 999999;
		skyMaxs[0][i] = skyMaxs[1][i] = -999999;
	}
}


void GL_ShowWholeSky (void)
{
	int		i;

	//!! WRONG !!
	for (i = 0; i < 6; i++)
	{
		skyMins[0][i] = skyMins[1][i] = -1;
		skyMaxs[0][i] = skyMaxs[1][i] = 1;
	}
}


void GL_AddSkySurface (surfacePlanar_t *pl, vec3_t vieworg)
{
	vec3_t	verts[MAX_CLIP_VERTS];
	int		i;
	vertex_t *v;

	if (gl_fastsky->integer)
		return;

	//!! clear skyMins/skyMaxs
	for (i = 0, v = pl->verts; i < pl->numVerts; i++, v++)
		VectorSubtract (v->xyz, vieworg, verts[i]);
	ClipSkyPolygon (pl->numVerts, verts[0], 0);
	//!! analyze skyMins/skyMaxs
}


int GL_TesselateSkySide (int side, bufVertex_t *vec, bufTexCoord_t *tex, float zFar)
{
	float	s, t, scale;
	int		i, numIndexes, ds, dt, si, ti;
	int		*idx, i1, i2;

	//!! WRONG !!
	for (i = 0; i < 2; i++)
	{
		float	v;

		v = floor (skyMins[i][side] * SKY_TESS_SIZE) / SKY_TESS_SIZE;
		if (v < -1) v = -1;
		skyMins[i][side] = v;

		v = ceil (skyMaxs[i][side] * SKY_TESS_SIZE) / SKY_TESS_SIZE;
		if (v > 1) v = 1;
		skyMaxs[i][side] = v;
	}

	if (skyMins[0][side] > skyMaxs[0][side] || skyMins[1][side] > skyMaxs[1][side])
		return 0;				// no visible sky surfaces on this plane

	// tesselate sky surface (up to 9 points per diminsion)
	gl_numVerts = 0;
	scale = zFar / 3;			// any non-zero value not works no TNT2 (but works with GeForce2)
	for (t = skyMins[1][side]; t <= skyMaxs[1][side]; t += 1.0f/SKY_TESS_SIZE)
		for (s = skyMins[0][side]; s <= skyMaxs[0][side]; s += 1.0f/SKY_TESS_SIZE)
		{
			MakeSkyVec (s, t, side, scale, tex->tex, vec->xyz);
			tex++;
			vec++;
			gl_numVerts++;
		}
	ds = (skyMaxs[0][side] - skyMins[0][side]) * SKY_TESS_SIZE + 1;
	dt = (skyMaxs[1][side] - skyMins[1][side]) * SKY_TESS_SIZE + 1;
	// generate indexes
	idx = gl_indexesArray;
	i1 = 0;
	i2 = ds;
	numIndexes = 0;
	for (ti = 0; ti < dt - 1; ti++)
	{
		for (si = 0; si < ds - 1; si++)
		{
			// triangle 1 (1-3-2)
			*idx++ = i1++;		// i1(1) ----- i1+1(2)
			*idx++ = i2;		//  |           |
			*idx++ = i1;		//  |           |
								// i2(3) ----- i2+1(4)
			// triangle 2 (3-4-2)
			*idx++ = i2++;
			*idx++ = i2;
			*idx++ = i1;
			numIndexes += 6;
		}
		i1++;
		i2++;
	}

	return numIndexes;
}
